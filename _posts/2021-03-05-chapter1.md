---
title: Object-Oriented Programming Using C++
---

### 1.1 ABSTRACT DATA TYPES - KIỂU DỮ LIỆU TRỪU TƯỢNG

Trước khi một chương trình được viết ra, chúng ta nên có một ý tưởng tốt về việc để hoàn thành các yêu cầu sẽ được thực hiện bởi chương trình đó. Vì thế, một khung của chương trình bao gồm các yêu cầu nên có trước giai đoạn viết chương trình. Đối với các dự dán càng lớn và càng phức tạp, thì càng cần có một giai đoạn phác thảo khung chương trình thật chi tiết. Chi tiết việc lập trình nên được trì hoãn đến giai đoạn sau của dự án. Cụ thể, các chi tiết về cấu trúc dữ liệu sẽ được sử dụng trong quá trình cài đặt chương trình không nên chỉ định ngày từ giai đoạn đầu.

Từ đầu, điều quan trọng nhất là xác định đầu vào đầu ra của mỗi yêu cầu. Ở giai đoạn bắt đầu, chúng ta nên quan tâm đến chương trình này làm gì, chứ không phải là nó như thế nào và nó hoạt động ra sao. Các hoạt động của chương trình nó quan trọng hơn là các bánh răng của cơ chế hoàn thành nó. Ví dụ, nếu mà một đối tượng cần hoàn thành một nhiệm vụ nào đó, thì đối tượng đó đó cần được chỉ rõ về các hành động thực hiện trên nó hơn là xét về cấu trúc bên trong nó. Các hành động này có thể tác động lên đối tượng, ví dụ: sửa đổi, tìm kiếm chi tiết bên trong đối tượng, hoặc là lưu trữ bên trong đối tượng. Sau khi các hoạt động này được xác định đúng, việc thực hiện chương trình có thể bắt đầu. Việc triển khai quyết định cấu trúc dữ liệu nào nên được sử dụng để có hiệu quả tốt nhất về mặt thời gian và không gian. Một mục được chỉ định trong điều khoản hoạt động được gọi là kiểu dữ liệu trừu tượng. Kiểu dữ liệu trừu tượng không phải là một phần của chương trình, bởi vì chường trình được viết bởi ngôn ngữ lập trình yêu cầu định nghĩa các cấu trúc dữ liệu, không đơn giản là cáp phép toán trên chúng. Tuy nhiên, một ngôn ngữ hướng đối tượng (OOL) như là C++ có thể liên kết trực với kiểu dữ liệu trừu tượng bằng cách cài đặt chúng dưới một lớp.

### 1.2 ENCAPSULATION ĐÓNG GÓI 

Lập trình hướng đối tượng (OOP) xoay quanh khái niệm về đối tượng. Tuy nhiên, các đối tượng được tạo bằng cách sử định nghĩa lớp. Một lớp là một khuôn mẫu phù hợp với các đối tượng được tạo ra. Lớp là một phần của phần mềm bao gồm dữ liệu và các chức năng hoạt động trên những dữ liệu này và có thể trên dữ liệu thuộc các lớp khác. Các hàm được định nghĩa trong một lớp được có là methods, và các biến được sử dụng trong lớp được gọi là dữ liệu được gọi là data members. Sự kết hợp dữ liệu và các hoạt động liên quan được gọi là đóng gói dữ liệu. Một đối tượng là một thực thể của lớp, một thực thể được tạo bằng định nghĩa của lớp.

Sự khác biệt so với các hàm trong ngôn ngữ lập trình không phải là hướng đối tượng, đối tượng làm cho sự kết nối giữa dữ liệu và các hàm thành viên chặt chẽ và ý nghĩa hơn. Trong ngôn ngữ không phải hướng đối tượng, khai báo dữ liệu và định nghĩa các hàm có thể xen kẻ trong toàn bộ chương trình, và chỉ trong tài liệu chương trình thể hiện được mối liên hệ giữa chúng. Trong ngôn ngữ hướng đối tượng, sự kết nối sẽ được thiết lập ngay từ đầu. Thực tế, chương trình dựa trên sự kết nối này. Một đối tượng được định nghĩa bởi dữ liệu và các hoạt động liên quan, và bởi vì có thể có nhiều đối tượng được sử dụng trong cùng một chương trình, các đối tượng giao biết bằng cách trao đổi thông điệp, tiết lộ rất ít chi tiết về cấu trúc bên trong của chúng khi cần thiết để trao đổi thông tin đầy đủ. Cấu trúc chương trình theo hướng đối tượng cho phép chúng ta hoàn thành một số mục tiêu.

Đầu tiên, sự kết hợp chặt chẽ của dữ liệu và các hoạt động có thể sử dụng tốt hơn nhiều trong việc mô hình hóa một phần của thế giới, đặt biệt được nhấn mạnh bởi các kĩ thuật phần mềm. Không đáng ngạc nhiên, OOP có nguồn gốc từ mô phỏng, nghĩa là, trong mô hình hóa các sự kiện trong thế giới thực. Đầu tiên, OOL được gọi là Simula, và nó được phát triển vào những năm 1960 ở Nauy.

Thứ hai, đối tượng cho phép tìm lỗi dễ dàng hơn, bởi vì các hoạt động cục bộ được giới hạn của các đối tượng. Ngay cả khi có các tác dụng phụ xảy ra chúng ta cũng dễ theo dõi.

Thứ ba, các đối tượng cho phép chúng che giấu một số chi tiết nhất điện về hoạt động của chúng đối với các đối tượng khác để các đối tượng này không bị ảnh hưởng bất lợi bởi các đối tượng khác, điều này được gọi là nguyên tắc che giấu dữ liệu. Trong ngôn ngữ không phải hướng đối tượng, nguyên tắc này có thể tìm thấy ở một mức độ nào đó trong trường hợp các biến cục bộ, hoặc như trong Pascal, trong các hàm hoặc các thủ tục cục bộ, chỉ có thể sử dụng và truy cập bởi các hàm định nghĩa chúng. Tuy nhiên, đây là một sự che giấu chặt chẽ hoặc không có sự che giấu nào cả. Đôi khi, chúng ta có thể cần sử dụng (lặp lại, như trong Pascal) một hàm f2 được định nghĩa trong f1 bên ngoài f1, nhưng chúng ta không thể làm điều đó. Đôi khi, chúng ta cần truy cập vào dữ liệu cục bộ đến f1 mà khong biết chính xác cấu trúc của dữ liệu này, nhưng chúng ta không thể. Do đó, một số sửa đổi là cần thiết, và nó được hoàn thành trong OOL.

Một đối tượng trong OOL giống như một chiếc đồng hồ. Là người dùng, chúng tôi quan tâm đến những gì mà kim hiển thị, nhưng không quan tâm đến cách làm việc bên trong của đồng đồ. Chúng tôi biết rằng có bánh răng và lò xo bên trong đồng hồ, nhưng vì chúng ta thường biết rất ít về lý do tại sao tất cả chúng lại nằm trong một cấu hình cụ thể, chúng ta không nên can thiệp vào cơ cấu máy móc của chúng để tránh làm hỏng chúng, vô tình hoặc cố ý. Cơ chế hoạt động của nó được che giấu, chúng ta không nên can thiệp vào nó, và đồng hồ được bảo vệ và hoạt động tốt hơn so với khi cấu tạo của nó được được mở ra cho mọi người xem.

Một đối tượng giống như một chiếc hộp đen có hành vi được xác định rõ ràng, và chúng ta sử dụng đối tượng bởi vì chúng ta biết nó làm gì, không phải vì chúng ta có cái nhìn sâu sắc về cách nó hoạt động. Độ mờ của các đối tượng vô cùng hữu ích cho việc duy trì chúng độc lập với nhau. Nếu các kênh thông tin liêc lạc giữa các đối tượng được định nghĩa rõ ràng, sau đó những thực hiện thay đổi bên trong đối tượng chỉ có thể ảnh hưởng đến các đối tượng khác khi những thay đối đó ảnh hưởng đến kênh giao tiếp. Biết loại dữ liệu được gửi và nhận bởi một đối tượng, đối tượng có thể được thay thế dễ dàng bằng một đối tượng khác ở trong một trường hợp cụ thể; một đối tượng mới có thể thực hiện cùng một tác vụ theo cách khác nhưng nhanh hơn trong một môi trường phần cứng nhất định. Một đối tượng chỉ tiết lộ ở mức vừa đủ để người dùng sử dụng nó. Nó có một phần công khai có thể truy cập được bởi một số người dùng khi người dùng dửi tin nhắn khớp với bất kì hàm thành viên nào được tiết lộ bởi đối tượng. Trong phần công khai này, đối tượng hiển thị các nút cho người dùng để có gọi các hoạt động của đối tượng. Người dùng chỉ biết tên các hoạt động và hành vi mong đợi.

Che giấu thông tin có xu hướng làm mờ ranh giới giữa dữ liệu và hoạt động. Trong các ngôn ngữ giống như Pascal, sự khác biệt giữa dữ liệu và hàm hoặc các thủ tục là rõ ràng. Chúng được định nghĩa khác nhau và có vai trò rất khác biệt. OOLs đặt dữ liệu và phương thức lại với nhau, và đối với người dùng đối tượng, sự khác biệt này ít được đáng chú ý. Đến một mức độ nào đó, điều này kết hợp các tính năng của ngôn ngữ chứ năng. LISP, một trong những ngôn ngữ lập trình sớm nhất, cho phép người dùng xử lý dử liệu và các chức năng tương tự, bởi vì cấu trúc của cả hai đều giống nhau.

Chúng ta đã phân biệt được sự khác nhau giữ các đối tượng củ thể và các loại đối tượng hoặc các lớp. Chúng ta viết các hàm sử dụng các biến khác nhau, và bằng cách tương tự, chúng tôi không muốn bị ép buộc  viết nhiều  khai bao đối tượng bằng số đối tượng mà chương trình yêu cầu. Một số đối tượng cùng loại và chúng tôi muốn sử  dụng tham chiếu đến đối tượng chung. Đối với một biến đơn, chúng ta phân biệt giữa khai báo kiểu và khai báo biến. Trong trường hợp các đối tượng, chúng ta có khai báo một lớp và khởi tạo một đối tượng. Ví dụ, trong khai báo lớp sao. C là một lớp và đối tượng 1 thông qua đối tượng 3 là các đối tượng.

```cpp
    class C{
        public:
            C(char *s = "", int i =0, double d = 1){
                strcpy(dataMember1,s);
                dataMember2 = i;
                dataMember3 = d;
            }
            void memberFunction1(){
                cout<<dataMember1<<" "<<dataMember2<<" "<<dataMember3<<"\n";
            }
            void memberFunction2(int i, char *s = "unknown"){
                dataMember2 = i;
                cout << i << " received from " << s << endl;
            }
        protected:
            char dataMember1[20];
            int dataMember2;
            double dataMember3;
    };
    C object1("object1",100,2000), object2("object2"), object3;
```

Truyền thông điệp (message passing) tương đương với gọi hàm trong các ngôn ngữ truyền thống. Tuy nhiên, để nhấn mạnh tính thực tế trong OOLs, các hàm thành viên có liên quan đến các đối tượng, thuật ngữ mới được sử dụng. Ví dụ, lời gọi đến hàm public memberFunction1() trong object1

```cpp
object1.memberFunction1()
```
được xem như thông điệp memberFunction1() được gửi đến object1. Khi nhận được thông báo, đối tượng sẽ gọi các hàm thành viên và hiển thị các thông tin liên quan. Thông điệp bao gồm các tham số như 

```cpp
object1.memberFunction1(123)
```

Một tính năng đặc biệt của C++ là có thể khai báo các lớp chung bằng cách sử dụng các kiểu tham số trong khai báo lớp. Ví dụ, nếu chúng ta cần khai báo một lớp sử dụng một mảng để lưu trữ một số item, thì chúng ta có thể khai báo lớp này là

```cpp
    class intClass{
        int storage[50];
    };
```

Tuy nhiên, ở đây chúng ta giới hạn khả năng sử dụng của lớp này chỉ với các số nguyên. Nếu chúng ta cần một lớp thực hiện các hoạt động tương tự intClass ngoại trừ việc nó hoát động trên số thực, sau đó cần khai báo mới, chẳng hạn như 

```cpp
    class floatClass{
        float storage[50];
    };
```

Nếu storage là giữ các cấu trúc, hoặc các con trỏ chỉ đến ký tự, sau đó thêm hai lớp nữa phải được khai báo. Nó sẽ tốt hơn nhiều nếu khai báo một lớp chung và quyết định những mục mà đối tượng đề cập đến chỉ khi xác định các đối tượng. Thật may mắn, C++ cho phép chúng ta khai báo lớp bằng cách như thế này, và xem ví dụ khai báo dưới đây:

```cpp
    template <class genType>
    class genClass{
        genType storage[50];
    };
```

Sau đó, chúng tôi đưa ra quyết định về cách khởi tạo genType
```cpp
genClass <int> intObject;
genClass <float> floatObject;
```

Lớp chung này là nên tàng để tạo thành hai lớp mới, genClass thuộc kiểu số nguyên và genClass thuộc kiểu số thực, và sau đó có hai lớp được dùng để tạo ra hai đối tượng, intObject và floatObject. Trong cách này, lớp chung thể hiện dưới các hình thức khác nhau tùy thuộc vào cách khai báo cụ thể. Một khai báo chung đủ để kích hoạt các biểu mẫu khác nhau.

Chúng ta có thể có thể đi xa hơn bằng cách không cam kết  với 50 ô nhớ trong  storage và bằng cách trì hoãn cho đến giai đoạn xác định đối tượng. Nhưng ở trong trường hợp, chúng ta có thể để một giá trị mặc định khi khai báo lớp bây giờ là

```cpp
    template <class genType, int size = 50>
    class genClass{
        genType storage[size];
    };
```

Bây giờ các đối tượng được định nghĩa là
```cpp
genClass<int> intObject1; //sử dụng kích thước mặc định
genClass<int,100> intObject2;
genClass<float,123> floatObject;
```

Phước pháp này sử dụng các kiểu chung  không chỉ giới hạn ở các lớp, chúng ta có thể dùng chúng trong khai báo hàm. Ví dụ, các hoạt động hoán đối hai giá trị có thể được định nghĩa bởi hàm:

```cpp
    template<class genType>
    void swap(genType& el1, genType& el2) {
        genType tmp = el1; el1 = el2; el2 = tmp;
	}
```

Ví dụ này cũng chỉ ra sự cần thiết của việc điều chỉnh các toán tử cài sẵn cho các tình huống riêng biệt. Nếu genType là một số, một kí tự hoặc một cấu trúc, thì gán toán tử "=" thực hiện đúng chức năng của nó. Nhưng nếu genType là một mảng, sau đó chúng ta có thể gặp vấn để ở trong hàm swap(). Vấn đề có thể được giải quyết bằng cách nạp thêm các toán tử bằng cách thêm nó vào chức năng yêu cầu của một kiểu dữ liệu cụ thể.

Sau đó một hàm chung đã được khai báo. Một hàm thích hợp có thể được tạo ra tại thời điểm biên dịch. Ví dụ, nếu trình biên dịch thấy 2 lệnh gọi:

```cpp
    swap(n,m); // đổi chỗ 2 số nguyên
    swap(x,y); // đổi chỗ 2 số thực
```

nó tạo ra hai hàm đổi chỗ được sử dụng trong quá trình thực thi chương trình.

### 1.3 INHERITANCE -Kế thừa

OOLs cho phép chúng ta tạo ra một hế thống phân cấp của các lớp để các đối tượng không phải là bản khởi tạo duy nhất của một lớp. Trước khi thảo luận về các vấn đề kế thừa, hay xem xét các định nghĩa lớp sau: 

```cpp
    // Lớp cha
    class Vehicle {
    public:
        string brand = "Ford";
        void honk() {
        cout << "Tuut, tuut! \n" ;
        }
    };

    // Lớp con
    class Car : public Vehicle {
    public:
        string model = "Mustang";
        string brand = "Ferrari"
    class Vinfast : public Car{
        string brand = "Vinfast";
        int price = 1000;
    }
    };

    int main() {
    Car myCar;
    myCar.honk();
    cout << myCar.brand + " " + myCar.model;
    return 0;
    }
```

Lớp Vehicle được gọi là lớp cơ cha hoặc lớp siêu cấp, và  các lớp khác được gọi là lớp con hoặc các lớp có nguồn gốc gới vì chúng có nguồn gốc từ lớp cha trong đó chúng có thể sử dụng các thành viên dữ liệu và các hàm thành viên được chỉ định trong lớp Vehicle như là protected hoặc public. Chúng được kế thừa tất cả thành viên từ lớp cha do đó chúng không cần định nghĩa lại giống như vậy. Tuy nhiên, một lớp con có thể ghi đè định nghĩa của một hàm thành viên với định nghĩa riêng của nó. Trong cách này, cả hai lớp cha và lớp con đều có mọt số biện pháp kiểm soát các hàm thành viên. 

Lớp cha có thể quyết định các hàm thành viên và dữ liệu thành viên có thể  được chia sẽ cho các lớp con để nguyên tắc ân thông tin không chỉ tuân theo đối với người sử dụng lớp cha, mà còn đối với các lớp con. Hơn thế nữa, các lớp con có thể quyết định các phần công khai của hàm thành viên và dữ liệu để giữ lại và sử dụng và để sửa đổi. Ví dụ. lớp con Car được kế thừa từ lớp cha Vehicle được kế thừa các thuộc tính và phương thức của lớp cha, tuy nhiên, lớp Car có thể sửa đổi thuộc tính của lớp Vehicle theo cách riêng của mình.

Một lớp con có thể thêm một vài thành viên mới của nó. Như vậy một lớp có thể trở thành một lớp cha khác cho các lớp con khác kế thừa theo hệ thống cấp bậc kéo dài đa thế hệ. Ví dụ, lớp Car là lớp con của lớp Vehicle, nhưng lớp Car lại là lớp cha của lớp Vinfast.

Sự kế thừa trong các ví dụ của chúng tôi được chỉ định bằng sách sử dụng từ public sau dấu hai chấm  trong tiêu đề địng nghĩa của lớp con. Kế thừa công khai có nghĩa là các thành viên trong lớp cha cũng là công khai trong lớp con và các thành viên bảo vệ cũng được bảo vệ. Trong trường hợp kế thừa được bảo vệ (với từ protected trong mệnh đề định nghĩa), cả hai thành viên công khai và bảo trong lớp cha cũng sẽ được bảo vệ trong lớp con. Cuối cùng đối với kế thừa riêng, cả thành viên công khai và bảo về của lớp cha đều trở thành riêng tư trong lớp con. Trong tất cả các loại kế thừa, các thành viên riêng tư của lớp cha không thể nào truy cập được từ bất kì lớp con nào. Các thành viên được bảo vệ trong lớp cha chỉ có thể truy cập được từ lớp con và không phải từ các lớp con khác.

Trong C++, có 3 kiểu truy cập:
**public**: Các thành viên có thể truy cập từ bên ngoài class.
**private**: Các thành viên không thể truy cập (hoặc xem) từ bên ngoài class.
**protected**: Các thành viên không thể truy cập từ bên ngoài class, tuy nhiên chúng có thể được truy cập từ các class kế thừa.


### 1.4 Pointer - Con trỏ

Các biến sử dụng trong một chương trình được coi như những chiếc hộp không bao giờ rỗng. Chúng được lấp đầy một số nội dung do người lập trình viên hoặc nếu chưa được khởi tạo, thì nó được khởi tạo bởi hệ điều hành. Một biến như vậy có ít nhất hai thuộc tính: nội dung (hoặc giá trị) của hộp và vì trí của cái hộp đó hoặc là ví trị của biến trong bộ nhớ máy tính. Nội dung này có thể là một số, một kí tự hoặc một thành phần phức tạp hơn như là cấu trúc. Tuy nhiên, nội dung này cũng có thể là vị trí của một biến khác, các biến có nội dung như vậy được gọi là con trỏ. Con trỏ thường là biến phụ trợ cho phép chúng ta truy cập vào giá trị của biến khác một cách gián tiếp. Một con trỏ tương tự như một đèn báo giao thông chỉ chúng ta đến một địa điểm nhất định hoặc một tờ giấy được ghi địa chỉ trên đó:

Ví dụ, một số khai báo sau:

```cpp
    int i = 15, j, *p, *q;
```

i, j là các biến số và p, q là các con trỏ chỉ số. Dấu sao phía trước p và q cho biết chứng năng của chúng. Giả sử địa chỉ của các biến i, j, p và q là 1080, 1082, 1084 và 1086, sau đó gán giá trị 15 cho biến i trong khai báo, vị trị và giá trị của biến  ở trong bộ nhớ máy tính ở trong hình 1.1a.

[](https://ibb.co/rsf654S)

Bây giờ, chúng ta có thể thực hiện gán p = i ( or p = (int*) i nếu trình biên dịch không chấp nhận nó), nhưng biến p được tạo ra đẻ lưu địa chỉ của một biến số nguyên, chứ không phải giá trị của nó. Do đó, gán biến đúng cách là p = &i, trong đó dấu và ở phía trước i có nghĩa là địa chỉ của i chứ không phải là nội dung của nó. Hình 1.1b minh họa cho tình huống này. Ở hình 1.1c, mũi tên chỉ từ p đến i là một con trỏ chưa địa chỉ của i.

Chúng ta có khả năng phân biệt được giá trị của p, là một địa chỉ, với giá trị của vị trị có địa chỉ mà con trỏ giữ. Ví dụ, để gán 20 cho biến được trỏ bới p, câu lệnh gán là:

```cpp
    *p = 20;
```
Dấu sao (*) là một toán tử điều hướng buộc hệ thống phải truy xuất nội dung của p trước tiên, sau đó truy cập vào vị trí có địa chỉ được lấy từ p, sau đó gán 20 cho vị trí này ( hình 1.1d). Hình 1.1e đến 1.1n cung cấp thêm một số ví dụ về các câu lệnh gán và cách lưu giá trị trong bộ nhớ máy tính.

[](https://ibb.co/xzQrcbt)

Trong thực tế, con trỏ nó cũng giống như tất cả các biến cũng có 2 thuộc tính: nội dung và địa chỉ. Địa chỉ này có thể lưu ở biến khác, sau đó trở thành một con trỏ đến một con trỏ.

Trong hình 1.1 địa chỉ của biến đã được gán cho một con trỏ. Tuy nhiên, con trỏ có thể xem được các địa chỉ ẩn danh, chỉ có thể truy cập thông qua địa chỉ của chúng chứ không phải như biến, truy cập bằng tên của chúng. Các vị trí này phải được đặt sang một phía bởi hệ thống quản lí bộ nhớ. Xuyên suốt thời gian chạy của chương trình, không giống như biến, các vị trí được phân phát tại thời điểm biên dịch.

[](https://ibb.co/KqLtRw7)

Để cấp phát động và phân bố bộ nhớ, 2 function được sử dụng. Function đầu tiên là **new**, lấy từ bộ nhớ nhiều không gian cần thiết để lưu trữ một đối tượng có kiểu theo sau **new**. Ví dụ:

```cpp
p = new int;
```

chương trình sẽ yêu cầu đủ không gian để lưu trữ một số nguyên, từ hệ thống quản lí bộ nhớ, và địa phần đầu của bộ nhớ này được lưu trử trong p. Bây giờ giá trị có thể gán cho khối bộ nhớ được trỏ tới bởi p một cách gián tiếp thông qua con trỏ, hoặc con trỏ p hoặc con trỏ q nào khác đã được gán địa chỉ lưu trữ trong p với phép gán q = p.

Nếu khoảng trống đã bị lấy mất bới một số nguyên có thể truy cập từ p nhưng không còn cần thiết nữa, nó có thể trả về vùng bộ nhớ trống do hệ điều hành quản lý bằng cách phát hành lệnh sau:

```cpp
delete p;
```

[](https://ibb.co/D1vJyYD)

Tuy nhiên, sau khi thực hiện mệnh lệnh, địa chỉ đầu của khối bộ nhớ vẫn còn trong p, theo chương trình có liên quan, khối không có tồn tại nữa. Nó giống như xem địa chỉ của một ngôi nhà đã bị phá hủy là địa của vị trí hiện tại. Nếu chúng ta sử đụng địa chỉ này để tìm một ai đó, thì kết quả có thể dễ dàng thấy trước. Tương tự, nếu sau khi phát hành câu lệnh delete chúng tôi không xóa địa chỉ từ biến con trỏ tham gia vào sự xóa bỏ, kết quả có thể là nguy hiểm, và chúng tôi có thể làm lỗi chương trình trình khi cố cắng truy cập vào địa chỉ không tồn tại, đặc biệt đói với các đối tượng phức tạp hơn là cái giá trị số. Vấn đề này gọi là **con trỏ lơ lững**. Để tránh vấn đề này, một địa chỉ phải được gán cho một con trỏ, nếu nó không thể là địa chỉ của bất kỳ vị trí nào, nó phải là một giá trị rỗng (NULL), đơn giản là 0. Sau đó thực hiện nhiệm vụ

```cpp
    p = 0;
```
Chúng ta có thể không nói răng p tham chiếu đến NULL hoặc trỏ  đến NULL nhưng p trở thành NULL hoặc o là NULL.

Một vấn đề khác liên quan đế việc xóa bộ nhớ là rò rĩ bộ nhớ. Xét hai dòng code sau:

```cpp
    p = new int;
    p = new int;
```

Sau khi phân bố bộ nhớ cho một số nguyên, cùng một con trỏ p được dùng đẻ cấp phát cho một ô khác. Sau khi thực hiện nhiệm vụ thứ hai, ô đầu tiên không thể truy cập được và cũng không khả dụng trong lần cấp phát tiếp theo xuyên suốt chương trình. Vấn đề là không giải phóng bộ nhớ với lệnh **delete**, bộ nhớ có thể truy cập từ biến p trước đó khi thực hiện nhiệm vụ thứ 2. Đoạn code nên cài đăt như sau:

```cpp
    p = new int;
    delete p;
    p = new int;
```

Vấn đề rò rỉ bộ nhớ có thể trở nên nghiêm trọng khi một chương trình sử dụng nhiều và nhiều hơn nữa bộ nhớ không giải phóng nó, cuối cùng làm hết bộ nhớ và dẫn đến kết thúc chương trình bất thường. Điều này đặt biệt quan trọng trong các chương trình được thực thi trong một thời gian dài, chẳng hạn như các chương trình ở servers.

### 1.4.1 Pointers and Arrays - Con trỏ và mảng

Trong phần trước, con trỏ p tham chiếu đến một khối bộ nhớ chứa một số nguyên. Một tình huống thú vị hơn là khi một con trỏ tham chiếu đến một cấu trúc dữ liệu động đã được tạo và sửa đổi. Đây là một tình huống mà chúng ta cần phải vượt qua các hạn chế do mảng áp đặt. Mảng trong C++ và hầu hết trong các ngôn ngữ lập trình, phải được khai báo trước, do đó, kích thước của mảng cần phải biết trước khi chương trình bắt đầu. Điều này có nghĩa là người lập trình cần có kiến thức tốt về vấn đề sẽ được lập trình để chọn kích thước mảng phù hợp. Nếu kích thước quá lớn, thì mảng sẽ chiếm không gian bộ nhớ một cách không cần thiết, đơn giản là lãng phí bộ nhớ. Nếu kích thước quá nhỏ, thì dẫn đến việc tràn mảng và chương trình sẽ bị hủy bỏ. Đôi khi việc dự đoán kích thước của mảng không hề đơn giản, do đó quyết định trì hoãn cho đến thời gian chạy, và sau đó cấp phát đủ bộ nhớ để giữ mảng.

Vấn đề được giải quyết khi sử dụng con trỏ. Xét hình 1.1b, trong hình này, con trỏ p trỏ đến vị trí 1080. Nhưng nó cũng cho phép truy cập vị trí 1082, 1084 và vân vân bởi vì các vị trí cách đều nhau. Ví dụ, để truy cập giá trị của biến j, là hàng xóm của i, nó đủ để thêm kích thước của một biến số nguyên đến địa chỉ của biến i lưu trong p để truy cập giá trị của j, cũng từ p. Và về cơ bản thì đây là cách C++ xử lí mảng. 

Xét khai báo sau:
```cpp
    int a[5], *p;
```

Khai báo trên xác định a là một con trỏ đến khối bộ nhớ và có thể chứa 5 số nguyên. Con trỏ a là cố định, nghĩa là, a phải được xem là một hằng số để bất kì nổ lực nào để gán một giá trị cho a, như là:

```cpp
    a = p;
```
Hoặc
```cpp
    a++;
```

được xem như là một lỗi biên dịch. Bời vì a là một con trỏ, ký hiệu con trỏ có thể sử dụng truy cập các ô của mạng a. Ví dụ, một một kí hiệu mảng được sử dụng trong vòng lặp cộng tất cả các số trong mảng a:

```cpp
    for (sum = a[0], i = 1; i < 5; i++)
        sum += a[i];
```

có thể được thay thế bằng kí hiệu con trỏ

```cpp
    for (sum = *a, i = 1; i < 5; i++)
        sum += *(a + i);
````

hoặc 

```cpp
    for (sum = *a, p = a+1; p < a+5; p++)
        sum += *p;
```

Bởi vì p là một biến, nó có thể được gán cho một mảng mới. Nhưng nếu mảng hiện tại được trỏ tới p mà không còn cần thiết nữa, nó nên được xử lý theo hướng dẫn sau

```cpp
    delete [] p;
```

Lưu ý việc sử dụng dấu ngoặc trống trong hướng dẫn. Dấu ngoặc cho biết p trỏ đến một mảng. Ngoài ra, **delete** nên được sử dụng với các con trỏ đã được gán một giá với từ khóa **new**. Vì lý do này, hai ứng dụng của **delete** sau đây có thể dẫn đến sự cố của chương trình: 

```cpp
    int a[10], *p = a;
    delete [] p;
    int n = 10, *q = &n;
    delete q;
```

Một loại mảng rất quan trọng đó là chuỗi, hoặc một mảng kí tự. Nhiều function được định nghĩa trước ở trên chuỗi.  Tên của các function này bắt đầu với từ **str**, như là strlen(s) để tìm độ dài của chuỗi s hoặc strcpy(s1,s2) để copy chuỗi s2 đến chuỗi s1. Điều quan trọng cần nhớ là tất cả các function đều giả định chuỗi kết thúc bằng kí tự null '\0'. Ví dụ, strcpy(s1,s2) sẽ tiếp tục copy cho đến khi tìm thấy kì tự này ở s2. Nếu một người lập trình không đưa kí tự này vào trong s2, việc copy sẽ dừng lại khi lần xuất hiện đầu  tiền của kí tự này được tìm thấy trong bộ nhớ máy tính sau vị trí s2. Điều này có nghĩa là việc copy được thực hiện đến các vị trí bên ngoài s1, điều này có thể dẫn đến sự cố của chương trình.

### 1.4.2 Poninter and Copy Constructors

Một số vấn đề có thể nảy sinh khi các thành viên dữ liệu con trỏ không được xử lý đúng cách khi copy data từ đối tượng này qua đối tượng khác. Xét định nghĩa sau:

```cpp
    struct Node {
        char *name;
        int age;
        Node(char *n = "", int a = 0) {
            name = strdup(n);
            age = a;
        }
    };
```
Mục đích của khai báo:

```cpp
    Node node1("Roger",20), node2(node1); //or node2 = node1;
```

là tạo đối tượng node1, gán giá trị cho hai thành viên dữ liệu trong node1, và sau đó tạo node2 và khởi tạo các thành viên dữ liệu giống như node1. Các đối tượng này phải là các thực thể độc lập để gán giá trị cho một trong số chúng sẽ không bị ảnh hướng đến các giá trị khác. Tuy nhiên, sau mệnh đề

```cpp
    strcpy(node2.name,"Wendy");
	node2.age = 30;
```

là lệnh in màn hình:

```cpp
    cout<<node1.name<<' '<<node1.age<<' '<<node2.name<<' '<<node2.age;
```
Hình 1.2
https://ibb.co/yNcBL2h

Tạo đầu ra
    "Wendy 30 Wendy 20"

Tuổi khác nhau, nhưng tên ở trong hai objects đều giống nhau. Điều gì sẽ xảy ra? Vấn đề là định nghĩa của Node không cung cấp hàm sao chép constructor

```cpp
    Node (const Node&);
```

điều này vô cùng cần thiết để thực hiện khai báo node2(node1) để khởi tạo node1. Nếu hàm constructor tạo bản sao người dùng bị thiếu, thì constructor sẽ được tạo tự đổng bởi trình biên dịch. Nhưng trình biên dịch tạo ra constructor thực hiện sao chép từng thành viên. bởi vì name là một con trỏ, constructor sap chép địa chỉ chuỗi node1.name đến node2.name, không phải là nội dung chuỗi, do đó ngay sai khi thực hiện khai báo, tình trạng như trong hình 1.2a. Bây giờ nếu mệnh đề

```cpp
    strcpy(node2.name,"Wendy");
	node2.age = 30;
```

được thực hiện, node2.age được cập nhật đúng cách, nhưng chuỗi "Roger" được trỏ bởi thành viên name của cả hai objects được ghi đè bởi "Wendy",  đều được trỏ bởi hai con trỏ (hình 1.2b). Để ngăn chặn điều này xảy ra, người dùng phải định nghĩa một hàm constructor thích hợp, như dưới đây:

```cpp
    struct Node {
        char *name;
        int age;
        Node(char *n = 0, int a = 0) {
            name = strdup(n);
            age = a;
        }
        Node(const Node& n) { // copy constructor;
            name = strdup(n.name);
            age = n.age;
        }
	};
```

Với constructor mới, khai báo node2(node1) tạo ra một bản sao khác của "Roger" được trỏ đến bởi node2.name (hinhf1.2c), và các nhiệm vụ cho thành viên viên dữ liệu trong một object không có ảnh hướng đến các thành viên trong các object khác, do đó sau khi thực hiện các nhiệm vụ

```cpp
    strcpy(node2.name,"Wendy");
	node2.age = 30;
```

đối tượng node1 vẫn khong thay đổi, hình minh họa 1.2d.

Lưu ý rằng một vấn đề tương tự được đưa ra bởi phép toán gán. Nếu một định nghĩa của toán tử gán không được cung cấp bởi người dùng, một phép gán

```cpp
    node1 = node2;
```

thực hiện copy từng thành viên, dẫn đến vấn đều giống như trong hình 1.2a-b. Để tránh vấn đề này, toán tử gán phải được nạp lên bởi người dùng. Đối với Node, việc nạp quá tải thực hiện bởi

```cpp
    Node& operator=(const Node& n) {
        if (this != &n) { // no assignment to itself;
            if (name != 0)
                free(name);
            name = strdup(n.name);
            age = n.age;
        }
        return *this;
    }
```

Trong đoạn code này, một con trỏ đặc biệt **this** đã được sử dụng. Mỗi object có thể truy cập địa chỉ của chính nó thông qua con trỏ **this**  là ***this** 


### 1.4.3 Pointers and Destructors

Điều gì sẽ xảy ra với các đối tượng được định nghĩa cục bộ của kiểu Node? Giống như tất cả các mục cục bộ, chúng bị phá hủy theo nghĩa là chúng trở nên không khả dụng bên ngoài khối mà chúng được xác định, và các vùng nhớ bị chiếm giữ cũng được giải phóng. Nhưng mặc dù một bộ nhớ bị chiếm giữ bởi một object của kiểu Node được giải phóng, không phải là tất cả bọ nhớ liên quan đến đối tượng này đều trở nên khả dụng. Một trong những thành viên dữ liệu của object là một con trỏ tới một chuỗi, do đó, bộ nhớ bị chiếm giữ bởi con trỏ thành viên dữ liệu được giải phóng, nhưng bộ nhớ được lấy bởi chuổi thì không. Sau khi object được hủy bỏ, chuỗi khả dụng có sẵn trước đó từ thành viên dữ liệu name trở nên không thể truy cập được (nếu không gán name cho một số object khác hoặc một biến chuỗi) và bộ nhớ bị chiếm giữ bởi chuỗi này không thể giải phóng được nữa, dẫn đến rò rĩ bộ nhớ. Đây là vấn đề với các objects có các thành viên dữ liệu trỏ đến các vị trí được phân động. Để tránh vấn đề này, một class nên bao gồm một định nghĩa về destructor. Destructor là một function tự động được gọi khi một đối tượng bị hủy bỏ, diễn ra khi thoát khỏi khối trong đó object được định nghĩa hoặc theo lệnh gọi "delete". Destructors không nhận các tham số và không trả về giá trị nào chỉ có thẻ có một destructor cho mỗi class. Ví dụ class Node, Destructor có thể được định nghĩa như sau:

```cpp
    ~Node() {
        if (name != 0)
            free(name);
    }
```

### 1.4.4 Poniters and Reference Variables

Xét các khác báo sau:

```cpp
    int n = 5, *p = &n, &r = n;
```

Biến p được khai báo kiểu int*, một con trỏ trỏ đến một số nguyên, và r là kiểu int&, một số biến số nguyên được tham chiếu. Một biến tham chiếu phải được khởi tạo trong khai báo của nó như một tham chiếu đến một biến cụ thể, và tham chiếu này không thể thay đổi. Điều này có nghĩa là biến tham chiếu không được trống. Một biến tham chiếu r có thể được coi là một thêm khác của một biến tham chiếu n để nếu n thay đổi thì r cũng thay đổi theo. Điều này là do một biến tham chiếu được trình bày như một con trỏ hằng đến biến.

Sau ba khai báo, thực hiện in

```cpp
    cout << n << ' ' << *p << ' ' << r << endl;
```

Đầu là là 5 5 5. Sau đó gán

```cpp
    n = 7;
```
cùng một câu lệnh in đầu ra là 7 7 7. Ngoài ra, một phép gán

```cpp
    *p = 9;
```

đưa về đầu ra 9 9 9, và thực hiện phép gán

```cpp
    r = 10;
```

nó cũng dẫn đến đầu ra là 10 10 10. Những lệnh trên chỉ rằng về mặt kí hiệu, những gì chúng ta có thể thực hiện với việc bỏ tham chiếu các biến con trỏ được thực hiện mà không cần bỏ tham chiếu với các biến tham chiếu. Điều này không phải là tình cờ, như đã đề cập, các biến tham chiếu được triển khai dưới dạng con trỏ hằng. Thay vì khai báo

```cpp
    int& r = n
```

chúng ta có thể sử dụng khai báo

```cpp
    int *const r = &n;
```
trong đó r là một con trỏ hằng đến một số nguyên, có nghĩa là phép gán

```cpp
    r = q;
```

trong đó q là một con trỏ khác, là một lỗi vì giá trị của r không thể thay đổi. Tuy nhiên, phép gán

```cpp
    *r = 1;
```

được chấp nhận nếu n là một số nguyên không đổi.

Điều quan trọng là cần lưu ý sự khác biệt giữa kiểu int *const và kiểu const int *. Cái sau là một kiểu con trỏ tới một số nguyên không đổi.

```cpp
    const int *s = &m;
```

sau đó gán

```cpp
    s = &m;
```

trong đó m là mốt số nguyên (cho dù là hằng số hay không) là có thể chấp nhận được, nhưng phép gán

```cpp
    *s = 2;
```

là sai, ngay cả khi m là một hằng số.

Các biến tham chiếu được dử dụng để truyền các tham số bằng cách tham chiếu đến cái lời gọi function. Truyền bằng tham chiếu là yêu cầu bắt buộc nếu một tham số thực tế sẽ được thay đổi vĩnh viên trong quá trình thực thi function. Điều này có thể thực hiện đối với các con trỏ (và trong C, đây là cơ chế có sẵn duy nhất có sẵn để chuyển qua tham chiếu) hoặc với tham chiếu biến. Ví dụ, sau khi khai báo một function

```cpp
    void f1(int i, int* j, int& k) {
        i = 1;
        *j = 2;
        k = 3;
	}
```

giá trị của các biến

```cpp
    int n1 = 4, n2 = 5, n3 = 6;
```

sau khi thực hiện lời gọi

```cpp
    f1(n1, &n2, n3);
```

là n1 = 4, n2 =2, n3 = 3.

Kiểu tham chiếu cũng được sử dụng để chỉ ra kiểu trả về của function. ví dụ, chúng ta có định nghĩa function

```cpp
    int& f2(int a[], int i) {
        return a[i];
	}
```

và khai bảo mảng

```cpp
    int a[] = {1,2,3,4,5};
```

chúng ta có thể sử dụng f2() ở bất khì phía nào của toán tử. Ví dụ, ở phía bên phải

```cpp
    n = f2(a,3);
```

hoặc phía bên trái

```cpp
    f2(a,3) = 6;
```

khi gán 6 cho a[3] có nghĩa là a = [1 2 3 5 3]. Lưu ý rằng chúng ta có thể thực hiện giống như một con trỏ, nhưng không được tham chiếu một cách rõ ràng

```cpp
    int* f3(int a[], int i) {
        return &a[i];
    }
```

và sau đó

```cpp
    *f3(a,3) = 6;
```

Các biến tham chiếu và kiểu trả về phải được sử dụng một cách thận trọng bởi vì nó có khả năng ảnh hưởng đến nguyên tắc che giấu thông tin  khi chúng được sử dụng không đúng cách. Xét class C:

```cpp
    class C {
	public:
        int& getRefN() {
            return n;
        }
        int getN() {
            return n;
        }
    private:
        int n;
	 } c;
```
và có các lệnh:

```cpp
    int& k =c.getRefN();
    k = 7;
    cout<<c.getN();
```

Mặc dù n được khai bảo **private**, sau phép gán đầu tiên nó có thể truy cập theo ý muốn từ bên ngoài thông qua k và được gán bất kì giá trị nào. Một tác vụ cũng có thể được thực hiện thông qua getRefN();

```cpp
    c.getRefN() = 9;
```

### 1.4.5 Pointer to Functions

Như đã chỉ ra trong phần 1.4.1, một trong những thuộc tính của của một biến là một địa chỉ của nó cho biết vị trí của nó trong bộ nhớ máy tính. Điều này cũng đúng với các function. Một trong những thuộc tính của function là địa chỉ của nó cho biết vị trí của phần thân function trong bộ nhớ. Khi gọi một function, hệ thống chuyển quyền điều khiển đến vị trí này để thực hiện function. Vì lý do này, nó có khả năng sử dụng con trỏ đến các functions. Những con trỏ này vô cũng hưu ích trong việc thực thi các functions (nghĩa là các hàm nhận các đối số) chẳng hạn như một tích phân.

Xét một function đơn giản sau:

```cpp
    double f(double x) {
        return 2*x;
	}
```

Với định nghĩa này, f là một con trỏ tới function f(), *f là một function của chính nó, và (*f)(7) là lời gọi function.

Bây giờ hãy xem xét viết một function C++ để tính tổng sau:

<-------------->

Để tính tổng, chúng ta phải cung cấp không giới hạn n và m, nhưng còn cung cấp thêm function f. Do đó, mong muốn thực  hiện nên cho phép truyền số không chỉ ở  dạng tham số, mà còn ở dạng function. Điều này được thực hiên trong C++ theo cách sau: 

```cpp
    double sum(double (*f)(double), int n, int m) {
        double result = 0;
        for (int i = n; i <= m; i++)
            result += f(i);
        return result;
	}
```

Trong định nghĩa của sum(), khai báo tham số chính đầu tiên 

```cpp
    double (*f)(double)
```

có nghĩa là f là một con trỏ đến một function với một tham số double và trả về giá trị double. Lưu ý rằng cần dấu ngoặc đơn () xung quanh *f. Bởi vì dấu ngoặc đơn được ưu tiên hơn toán tử tham chiếu *, biểu thức 

```cpp
    double *f(double)
```

khai báo một function và trả về giá trị double.

Bây giờ, có thể gọi hàm sum() bằng bất kì cách xây dựng nào hoặc người dùng xác định các function double nhận các đối số double, như 

```cpp
    cout << sum(f,1,5) << endl;
	cout << sum(sin,3,7) << endl;
```

Một ví dú khác về một hàm tìm gốc của một hàm liên tục trong một khoảng. Gốc được tìm thấy bằng cách lặp đi lặp lại  chia đôi một khảng và tìm một điểm giữa của khoảng hiện tại. Nếu giá trị hàm của điểm ở giữa bằng 0 hoặc khoảng nhỏ hơn một số giá trị nhỏ, điểm ở giữa được trả về. Nếu giá trị của hàm ở giới hạn bên trái của khoảng hiện tại và điểm ở giữa có dấu hiệu ngược lại, tiếp tục tìm kiếm trong nửa khoảng bên trái hiện tại, nếu không, khoảng hiện tại sẽ là nửa khoảng bên phải. Đây là một triên khai của thuật toán này:

```cpp
    double root(double (*f)(double), double a, double b, double epsilon) {
        double middle = (a + b) / 2;
        while (f(middle) != 0 && fabs(b - a) > epsilon) {
            if (f(a) * f(middle) < 0) // if f(a) and f(middle) have
                b = middle; // opposite signs;
            else a = middle;
            middle = (a + b) / 2;
        }
        return middle;
    }
``` 

### 1.5 Polymorphism - Tính đa hình

Tính đa hình đề cập đến khả năng tiếp nhận từ nhiều hình thức. Trong bối cảnh của lập trình hướng đối tượng điều này có nghĩa là cùng một tên function biểu thị nhiều functions thành viên của các objects khác nhau. Xét ví dụ sau:

```cpp
    class Class1 {
	public:
        virtual void f() {
            cout << "Function f() in Class1\n";
        }
        void g() {
            cout << "Function g() in Class1\n";
        }
    };
    class Class2 {
    public:
        virtual void f() {
            cout << "Function f() in Class2\n";
        }
        void g() {
            cout << "Function g() in Class2\n";
        }
    };
    class Class3 {
    public:
        virtual void h() {
            cout << "Function h() in Class3\n";
        }
	};

    int main() {
        Class1 object1, *p;
        Class2 object2;
        Class3 object3;
        p = &object1;
        p->f();
        p->g();
        p = (Class1*) &object2;
        p->f();
        p->g();
        p = (Class1*) &object3;
        p->f(); // possibly abnormal program termination;
        p->g();
        // p->h(); // h() is not a member of Class1;
        return 0;
	 }
```

Đầu ra của chương trình này như sau: 
    Function f() in Class1
	Function g() in Class1
	Function f() in Class2
	Function g() in Class1
	Function h() in Class3
	Function g() in Class1

Chúng ta không nên ngạc nhiên khi p được khai báo là một con trỏ tới object1 của loại lớp Class1, sau đó hai functions thành viên được kích hoạt được định nghĩa trong Class1. Nhưng sau đó p trở thành con trỏ tới object1 của loại lớp Class2, sau đó p->f() kích hoạt một functions được định nghĩa trong Class2. Trong khi p->g() kích hoạt một function trong Class1. Tại sao lại như thế? Sự khác biệt nằm ở thời điểm đưa ra quyết định về function được gọi.

Trong trường hợp  **ràng buộc tĩnh**, quyết định liên quan đến một functions sẽ được thực thi được xác định tại thời điểm trình biên dịch. Trong trường hợp **ràng buộc động**, quyết định được trì hoãn cho đến thời gian chạy. Trong C++, ràng buộc động được thi hành bằng cách khai báo một hàm ảo. Trong cách này, nếu hàm ảo được gọi, thì hàm được chọn để thực thi không phụ thuộc vào loại con trỏ được xác định bởi khai báo, nhưng phụ thuộc về loại giá trị mà con trỏ hiện có. Trong ví dụ của chúng tôi, con trỏ p đã được khai báo kiểu Class1*. Do đó, nếu p trỏ đến hàm g() là không ảo, sau đó thì bất kì ở nơi nào trong chơi trình xảy ra lệnh gọi p->g(),đây luôn luôn được xem như là một lời gọi hàm g() được định nghĩa trong Class1. Điều này do trình biên dịch đưa ra quyết định dựa trên khai báo kiểu của p và thực tế là g() không phải là ảo. Đối với các hàm ảo tình hình thay đổi mạnh mẽ. Lần này, quyết định được đưa ra trong thời gian chạy: nếu một hàm là ảo, hệ thống xem xét loại giá trị của con trỏ hiện tại và gọi hàm thành viên thích hợp. Sau đó khai báo ban đầu của p là kiểu Class1*, hàm ảo f() thuộc Class1 được gọi, trong khi chỉ định p, địa chỉ của object2 thuộc kiểu Class2 đã được gọi.

Lưu ý răng sau khi p được gán địa chỉ của object3, nó vẫn gọi g() được định nghĩa trong Class1. Điều này là do g() không được định nghĩa trong Class3 và g() được gọi từ Class1. Nhưng nổ lực gọi p->f() dẫn đến sự cố chương trình, hoặc đầu ra sai vì C++ chọn hàm ảo đầu tiên trong Class3, bởi vì f() được khai báo là ảo trong Class1 để hệ thống cố gắng tìm, không thành công, trong Class3 hàm f() được định nghĩa. Ngoài ra, mặc dù thực tế là p trỏ đến object3, lệnh p->h() dẫn đến lỗi biên dịch, bởi vì trình biên dịch không tìm thấy h() trong Class1, trong đó Class1* vẫn là loại con trỏ p. Đối với trình biên dịch, nó không có về đề là h() được định nghĩa trong Class3 (có thể là ảo hoặc không).

Tính đa hình là một công cụ mạnh mẽ trong lập trình hướng đối tượng, nó là đủ để gửi một tin nhắn tiêu chuẩn tới một vài đối tượng khác nhau nà không chỉ định cách thức xử lí như thế nào. Không cần biết loại của đối tượng là gì. Người nhận có trách nhiệm phiên dịch thông điệp và làm theo nó. Người gửi không phải sửa đổi tin nhắn tùy thuộc vào loại người nhận. Không cần đến mệnh đề **switch** hoặc **if-else**. Ngoài ra, các đơn vị mới có thể thêm vào một chương trình phức tạp mà không cần biên dịch lại toàn bộ chương trình.

### 1.6 C++ and Object-Oriented Programming

Các cuộc thảo luận trước đã giả định rằng C++ là ngôn ngữ hướng đối tượng, và tất cả các tính năng của ngôn ngữ hướng đối tượng mà chúng ta đã thảo luận, minh họa với mã C++. Tuy nhiên, C++ không thuần khiết là một ngôn ngữ hướng đối tượng. C++ là ngôn ngữ hướng đối tượng hơn C hoặc Pascal, không có các tính năng hướng đối tượng hoặc Ada, hỗ trợ cho các Class (packages) và instances. Tuy nhiên, C++ ít hướng đối tượng hơn các ngôn ngữ hướng đối tượng khác như Smalltalk hoặc Eiffel.

C++ không thực thi tiếp cận hướng đối tượng. Chúng ta có thể lập trình trong C++ mà không biết các tính năng như vậy là một phần của ngôn ngữ. Lý do cho điều này chính là sự phổ biến của C, C++ là bản nâng cấp của C, vì một lập trình viên C có thể dễ dàng chuyển qua C++ chỉ thích nghỉ với các tính năng quen thuộc như I/O, cơ chế gọi tham chiếu, giá trị mặc định đối với các tham số của hàm, nạp chồng toán tử, hàm nội tuyến, và những thứ tương tự. Sử dụng ngôn ngữ lập trình hướng đối tượng như là C++ không đảm bảo rằng chúng tôi đang lập trình hướng đối tượng. Mặc khác, không phải lúc nào cũng cần thiết phải gọi toàn bộ các máy móc của các lớp và các hàm thành viên, đặc biệt trong chương trình nhỏ, không thực hiện lập trình hướng đối tượng không hẳn là một bất lợi. Ngoài ra, C++ dễ tích hợp với mã C hiện có hơn các ngôn ngữ lập trình hướng đối tượng khác.

C++ có thuận lợi đóng gói tuyệt vời cho phép kiểm soát các thông tin được ẩn đi. Tuy nhiên, có một sự nới lỏng đói với quy tắc này trong việc sử dụng lời gọi các hàm bạn bè. Vấn đề là thông tin cá nhân của một lớp nhất định không thể truy cập bởi bất kì ai,  và mọi thông tin công khai thì mọi người dùng có thể truy cập. Nhưng thỉnh thoảng chúng tôi chỉ muốn cho phép người dùng có quyền truy cập đến kho thông tin riêng tư. Điều này có thể thực hiện nếu class liệt kê các chức nagnws của người dùng dưới dạng bạn bè. Ví dụ, nếu định nghĩa là:

```cpp
    class C {
        int n;
        friend int f();
    } ob;
```

hàm f() có quyền truy cập trực tiếp đến biến n thuộc lớp C,  như trong 

```cpp
    int f ()
	{ return 10 * ob.n; }
````

Điều này có thể được coi là vi phạm nguyên tắc che giấu thông tin, tuy nhiên, bản thân class C cấp quyền công khai cho một số người dùng những gì là riêng tư và không thể truy cập đối với những người khác. Như vậy, bởi vì lớp có quyền kiểm soát những gì cần xen xét một hàm bạn bè, cơ chế hàm bạn bè có thể xem xét như là một tiện ích mở rộng của nguyên tắc che giấu thông tin. Cơ chế này thừa nhận rằng, nó được sử dụng để tạo điều kiện lập trình và tăng tốc độ thực hiện, bởi vì viết code mà không sử dụng đến hàm bạn bè có thể là một vấn đề lớn. Việc nới lỏng một số quy tắc như vậy không phải là hiếm trong khoa học máy tính, các ví dụ khác bao gồm sự tồn tại của vòng lặp trong ngôn ngữ chức năng, như là LISP, hoạc lưu trữ một số thông tin ở đầu tệp dữ liệu vi phạm mô hình quan hệ cơ sở dữ liệu, như trong dBaseIII+.